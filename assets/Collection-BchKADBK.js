import{aw as U,b as A,G as E,a0 as b,e as w,Q as x,d as S,N as R,a8 as _,U as C,P as $,K as k,ax as D,O as F}from"./index-gY0TI7hK.js";import{r as L,S as O}from"./index-BjAkP4i8.js";import{D as j,i as W,C as q}from"./useForwardExpose-DqcwLvOy.js";import{c as g}from"./usePrimitiveElement-BIB6ps2a.js";function H(i,e="reka"){return`${e}-${U?.()}`}function z(i,e){const s=A(i);function l(u){return e[s.value][u]??s.value}return{state:s,dispatch:u=>{s.value=l(u)}}}function B(i,e){const s=A({}),l=A("none"),a=A(i),u=i.value?"mounted":"unmounted";let c;const f=e.value?.ownerDocument.defaultView??j,{state:d,dispatch:o}=z(u,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),t=n=>{if(W){const m=new CustomEvent(n,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(m)}};E(i,async(n,m)=>{const I=m!==n;if(await x(),I){const T=l.value,M=y(e.value);n?(o("MOUNT"),t("enter"),M==="none"&&t("after-enter")):M==="none"||M==="undefined"||s.value?.display==="none"?(o("UNMOUNT"),t("leave"),t("after-leave")):m&&T!==M?(o("ANIMATION_OUT"),t("leave")):(o("UNMOUNT"),t("after-leave"))}},{immediate:!0});const r=n=>{const m=y(e.value),I=m.includes(n.animationName),T=d.value==="mounted"?"enter":"leave";if(n.target===e.value&&I&&(t(`after-${T}`),o("ANIMATION_END"),!a.value)){const M=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",c=f?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=M)})}n.target===e.value&&m==="none"&&o("ANIMATION_END")},v=n=>{n.target===e.value&&(l.value=y(e.value))},N=E(e,(n,m)=>{n?(s.value=getComputedStyle(n),n.addEventListener("animationstart",v),n.addEventListener("animationcancel",r),n.addEventListener("animationend",r)):(o("ANIMATION_END"),c!==void 0&&f?.clearTimeout(c),m?.removeEventListener("animationstart",v),m?.removeEventListener("animationcancel",r),m?.removeEventListener("animationend",r))},{immediate:!0}),p=E(d,()=>{const n=y(e.value);l.value=d.value==="mounted"?n:"none"});return b(()=>{N(),p()}),{isPresent:w(()=>["mounted","unmountSuspended"].includes(d.value))}}function y(i){return i&&getComputedStyle(i).animationName||"none"}var J=S({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(i,{slots:e,expose:s}){const{present:l,forceMount:a}=R(i),u=A(),{isPresent:c}=B(l,u);s({present:c});let f=e.default({present:c.value});f=L(f||[]);const d=_();if(f&&f?.length>1){const o=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${o}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(t=>`  - ${t}`).join(`
`)].join(`
`))}return()=>a.value||l.value||c.value?C(e.default({present:c.value})[0],{ref:o=>{const t=q(o);return typeof t?.hasAttribute>"u"||(t?.hasAttribute("data-reka-popper-content-wrapper")?u.value=t.firstElementChild:u.value=t),t}}):null}});const P="data-reka-collection-item";function X(i={}){const{key:e="",isProvider:s=!1}=i,l=`${e}CollectionProvider`;let a;if(s){const t=A(new Map);a={collectionRef:A(),itemMap:t},F(l,a)}else a=$(l);const u=(t=!1)=>{const r=a.collectionRef.value;if(!r)return[];const v=Array.from(r.querySelectorAll(`[${P}]`)),p=Array.from(a.itemMap.value.values()).sort((h,n)=>v.indexOf(h.ref)-v.indexOf(n.ref));return t?p:p.filter(h=>h.ref.dataset.disabled!=="")},c=S({name:"CollectionSlot",setup(t,{slots:r}){const{primitiveElement:v,currentElement:N}=g();return E(N,()=>{a.collectionRef.value=N.value}),()=>C(O,{ref:v},r)}}),f=S({name:"CollectionItem",inheritAttrs:!1,props:{value:{validator:()=>!0}},setup(t,{slots:r,attrs:v}){const{primitiveElement:N,currentElement:p}=g();return k(h=>{if(p.value){const n=D(p.value);a.itemMap.value.set(n,{ref:p.value,value:t.value}),h(()=>a.itemMap.value.delete(n))}}),()=>C(O,{...v,[P]:"",ref:N},r)}}),d=w(()=>Array.from(a.itemMap.value.values())),o=w(()=>a.itemMap.value.size);return{getItems:u,reactiveItems:d,itemMapSize:o,CollectionSlot:c,CollectionItem:f}}export{J as P,X as a,H as u};
